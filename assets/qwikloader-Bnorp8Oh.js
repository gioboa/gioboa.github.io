const o=document,l=window,h=new Set,f=new Set([o]);let R;const L=(t,e)=>Array.from(t.querySelectorAll(e)),j=t=>{const e=[];return f.forEach(n=>e.push(...L(n,t))),e},N=t=>{m(t),L(t,"[q\\:shadowroot]").forEach(e=>{const n=e.shadowRoot;n&&N(n)})},A=t=>t&&typeof t.then=="function",P=(t,e,n=e.type)=>{j("[on"+t+"\\:"+n+"]").forEach(r=>{k(r,t,e,n)})},W=t=>{if(t._qwikjson_===void 0){let e=(t===o.documentElement?o.body:t).lastElementChild;for(;e;){if(e.tagName==="SCRIPT"&&e.getAttribute("type")==="qwik/json"){t._qwikjson_=JSON.parse(e.textContent.replace(/\\x3C(\/?script)/gi,"<$1"));break}e=e.previousElementSibling}}},T=(t,e)=>new CustomEvent(t,{detail:e}),k=async(t,e,n,r=n.type)=>{const s="on"+e+":"+r;t.hasAttribute("preventdefault:"+r)&&n.preventDefault(),t.hasAttribute("stoppropagation:"+r)&&n.stopPropagation();const C=t._qc_,w=C&&C.li.filter(a=>a[0]===s);if(w&&w.length>0){for(const a of w){const p=a[1].getFn([t,n],()=>t.isConnected)(n,t),g=n.cancelBubble;A(p)&&await p,g&&n.stopPropagation()}return}const x=t.getAttribute(s),S=t.qDispatchEvent;if(S)return S(n,e);if(x){const a=t.closest("[q\\:container]:not([q\\:container=html]):not([q\\:container=text])"),p=a.getAttribute("q:base"),g=a.getAttribute("q:version")||"unknown",D=a.getAttribute("q:manifest-hash")||"dev",F=new URL(p,o.baseURI);for(const I of x.split(`
`)){const d=new URL(I,F),O=d.href,u=d.hash.replace(/^#?([^?[|]*).*$/,"$1")||"default",J=performance.now();let c,b,q;const M=I.startsWith("#"),v={qBase:p,qManifest:D,qVersion:g,href:O,symbol:u,element:t,reqTime:J};if(M){const i=a.getAttribute("q:instance");c=(o["qFuncs_"+i]||[])[Number.parseInt(u)],c||(b="sync",q=Error("sym:"+u))}else{_("qsymbol",v);const i=d.href.split("#")[0];try{const E=import(i);W(a),c=(await E)[u],c||(b="no-symbol",q=Error(`${u} not in ${i}`))}catch(E){b||(b="async"),q=E}}if(!c){_("qerror",{importError:b,error:q,...v}),console.error(q);break}const V=o.__q_context__;if(t.isConnected)try{o.__q_context__=[t,n,d];const i=c(n,t);A(i)&&await i}catch(i){_("qerror",{error:i,...v})}finally{o.__q_context__=V}}}},_=(t,e)=>{o.dispatchEvent(T(t,e))},U=t=>t.replace(/([A-Z])/g,e=>"-"+e.toLowerCase()),$=async t=>{let e=U(t.type),n=t.target;for(P("-document",t,e);n&&n.getAttribute;){const r=k(n,"",t,e);let s=t.cancelBubble;A(r)&&await r,s||(s=s||t.cancelBubble||n.hasAttribute("stoppropagation:"+t.type)),n=t.bubbles&&s!==!0?n.parentElement:null}},Z=t=>{P("-window",t,U(t.type))},B=()=>{const t=o.readyState;if(!R&&(t=="interactive"||t=="complete")&&(f.forEach(N),R=1,_("qinit"),(l.requestIdleCallback??l.setTimeout).bind(l)(()=>_("qidle")),h.has("qvisible"))){const e=j("[on\\:qvisible]"),n=new IntersectionObserver(r=>{for(const s of r)s.isIntersecting&&(n.unobserve(s.target),k(s.target,"",T("qvisible",s)))});e.forEach(r=>n.observe(r))}},y=(t,e,n,r=!1)=>{t.addEventListener(e,n,{capture:r,passive:!1})},m=(...t)=>{for(const e of t)typeof e=="string"?h.has(e)||(f.forEach(n=>y(n,e,$,!0)),y(l,e,Z,!0),h.add(e)):f.has(e)||(h.forEach(n=>y(e,n,$,!0)),f.add(e))};if(!("__q_context__"in o)){o.__q_context__=0;const t=l.qwikevents;t&&(Array.isArray(t)?m(...t):m("click","input")),l.qwikevents={events:h,roots:f,push:m},y(o,"readystatechange",B),B()}
